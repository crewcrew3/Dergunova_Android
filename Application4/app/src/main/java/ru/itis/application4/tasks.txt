Таски:
(сделано) 1. Запросить пермишон на уведы (Нуу я вроде запросила лол)
(сделано) 2. Переделать блок кода с if-else в when
(сделано) 3. Открытие приложения через уведу идет через PendingIntent
(нет, это просто extras в PendingIntent) 4. Возможно ли такое, что тост при открытии приложения через уведу надо делать через бродкаст ресивер??
(сделано, но не совсем понятно) 5. PermissionHandler какие-то контракты в инит блоке завести и чтобы утечки памяти не было из-за mainActivity, чек второе видео (капец ничего не понятно.)
(сделано) 6. Поменять в мейн фрагменте нотификатион тайп при созданиий новой уведы
(сделано)7. Убедись что все делаешь правильно:
        Передаешь адаптеру спиннера список айдишников канала, который берешь прямо из констант
        Логика в айтем селектед(от чего лучше отталкиваться, просто от позиции элемента в спиннере или от его текстового значения? Текствое значение представляет из себя айдишник. Можно в enum-класс добавить поле с ним и сравнивать.)
(сделано) 8. Если уже загрузил изображение и пользователь на него тыкает - показывать тост, что изображение уже загружено.
(сделано) 9. Вынести логику доставания ресурса из холдера!!

Вопросы к преподу:
(избыточно)1. Получить ответ на 1 вопрос про аппКонтекст (чат жпт говорит что не обязательно на налл проверять)
(мне кажется, очевидно, первое) 2. Текст уведомления должен быть как просто setText() или как LargeContent()?
(избыточно)3. Вопрос про избыточность канала(чек тг)
4. Как метод initLaunchers() позволяет избежать утечек памяти? Почему нельзя как аргумент класса просто передать активити?
(мультиплай с помощью мапы) 5. PermissionHandler про multiplePermissions
(позицию ок)6. Здесь лучше использовать позицию или текст в текст вью элемента(учитывая, что у меня названия элементов в спиннера = айди каналов)

    override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                       // Определяем тип уведомления на основе позиции
                       selectedNotificationType = when (position) {
                           0 -> NotificationType.MAX
                           1 -> NotificationType.HIGH
                           2 -> NotificationType.DEFAULT
                           3 -> NotificationType.LOW
                           else -> null
                       }
                   }

Просто мои вопросы(к чатику, к преподу)
1. Почему имя у канала не может быть в качестве id? В какой ситуации нам понадобится создавать каналы уведомлений с одинаковыми именами но разными id?
Ответ от чата жпт: Функциональность: ID канала используется для программного управления уведомлениями (например, для обновления, удаления или изменения настроек канала). Имя канала, в свою очередь, предназначено только для отображения пользователю.
                   Изменяемость: Имя канала может быть изменено в будущем, в то время как ID должен оставаться постоянным для обеспечения правильной работы уведомлений.

                   Ситуации, когда нужны каналы с одинаковыми именами, но разными ID:
                   Разные категории уведомлений: Вы можете создать несколько каналов для разных категорий уведомлений, где пользователи могут видеть одно и то же имя, но с разными ID. Например, у вас может быть канал "Сообщения" для личных сообщений и другой канал "Сообщения" для групповых чатов. Эти каналы могут иметь разные настройки (например, звук, вибрация и т. д.).
                   Разные уровни важности: Если у вас есть несколько типов уведомлений с одинаковым именем, но разной важностью, вы можете создать отдельные каналы для каждого уровня важности. Например, у вас может быть канал "Обновления", который используется для уведомлений о новых версиях приложения, и другой канал "Обновления", который используется для менее важных уведомлений.
                   Разные источники уведомлений: Если ваше приложение получает уведомления из разных источников (например, серверные уведомления и локальные уведомления), вы можете создать каналы с одинаковыми именами, но с разными ID для управления ими отдельно.

2. В чем суть PendingIntent? В том, что мы не пересоздаем интент?
Ответ от чата жпт: PendingIntent в Android — это специальный объект, который предоставляет возможность другим приложениям (или самой системе) выполнять операции от имени вашего приложения в будущем. Он используется для создания "отложенных" намерений, которые могут быть выполнены позже, даже если ваше приложение не активно или не запущено в данный момент.
                    Основные аспекты PendingIntent:

                    Отложенные действия: PendingIntent позволяет вам создать намерение (Intent), которое будет выполнено позже. Например, вы можете создать PendingIntent для отправки уведомления, запуска активности или выполнения службы в определенный момент времени.
                    Использование с другими компонентами: PendingIntent часто используется в сочетании с компонентами, которые могут вызывать ваше приложение, такими как AlarmManager, NotificationManager, AppWidgetManager и т. д. Это позволяет им запускать действия вашего приложения в нужный момент.
                    Безопасность: PendingIntent может быть передан другому приложению, и при этом сохраняется контекст вашего приложения. Это означает, что, когда вызывается PendingIntent, оно будет иметь доступ к вашему приложению, как если бы оно было вызвано непосредственно из вашего кода.

                    Типы PendingIntent: Существует три основных типа PendingIntent:
                    PendingIntent.getActivity(): Используется для запуска активности.
                    PendingIntent.getService(): Используется для запуска службы.
                    PendingIntent.getBroadcast(): Используется для отправки широковещательного сообщения.

3. Что такое @SuppressLint("InlinedApi")?
Ответ от чатика: Аннотация @SuppressLint("InlinedApi") в Android используется для подавления предупреждений линтера, которые могут возникнуть в результате использования API, которые помечены как "инлайн" (или "инлайновые"). Это означает, что они могут быть доступны только в определенных версиях Android или могут иметь ограничения по использованию.)

4. permissions.toTypedArray()????
Ответ: просто превращает коллекцию в массив соответствующего типа


Факты:
1. Если отправить 2 уведы с одинаковым ID, то новое уведомление заменяет старое(например редактирование соо в тг)
2. Не делать контекстносодержащие классы, вьюшки, классы андроида lateinit var. Можно делать собственные классы, но без всяких андроидовских зависимостей

Старенькое:
1. Реализация класса PermissionHandler с SinglePermission
class PermissionsHandler(
    private val onSinglePermissionGranted: (() -> Unit)? = null,
    private val onSinglePermissionDenied: (() -> Unit)? = null,
    private val onMultiplePermissionGranted: Map<String, () -> Unit> = emptyMap(),
    private val onMultiplePermissionDenied: Map<String, () -> Unit> = emptyMap()
) {

    private var activity: AppCompatActivity? = null
    private var singlePermissionResult: ActivityResultLauncher<String>? = null
    private var multiplePermissionResult:  ActivityResultLauncher<Array<String>>? = null

    fun initLaunchers(activity: AppCompatActivity) {
        if (this.activity == null) {
            this.activity = activity
        }

        if (singlePermissionResult == null) {
            singlePermissionResult = this.activity?.registerForActivityResult(
                contract = ActivityResultContracts.RequestPermission(),
                callback = { isGranted ->
                    if (isGranted) {
                        onSinglePermissionGranted?.invoke()
                    } else {
                        onSinglePermissionDenied?.invoke()
                    }
                }
            )
        }

        if (multiplePermissionResult == null) {
            multiplePermissionResult = this.activity?.registerForActivityResult(
                contract = ActivityResultContracts.RequestMultiplePermissions(),
                callback = { dataMap ->
                    dataMap.forEach { (permission, isGranted) -> //пара значений - разрешение и Boolean(дано оно или нет)
                        if (isGranted) {
                            onMultiplePermissionGranted[permission]?.invoke()
                        } else {
                            onMultiplePermissionDenied[permission]?.invoke()
                        }
                    }
                }
            )
        }
    }

    fun requestSinglePermission(permission: String) {
        singlePermissionResult?.launch(permission) //выполняет контракт с input = permission (запускает действие)
    }

    fun requestMultiplePermission(permissions: List<String>) {
        multiplePermissionResult?.launch(permissions.toTypedArray()) //преобразует список в массив с соответствующим типом данных
    }
}